<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0"><!-- name 屬性 是用來告訴瀏覽器，這個 <meta> 標籤的用途是什麼。  -->
<title>草莓到SPEED方塊動畫</title>
<style>
  /* html 是整個房子的最外牆

body 是房子裡面的主要房間 */
  body, html {
    margin:0; 
    padding:0; 
    overflow:hidden; 
    background:#f8e2cc; 
    font-family:sans-serif;
  }
  canvas {
    display:block;
    /* 因為 canvas 預設是 inline（像文字）加上 display: block 才能避免它下面出現奇怪空白。
    inline 元素會：和文字一樣排在行內，下方會有 “基線空白”（因為擺字的空間） */
  }
</style>
</head>
<body>

<canvas id="intro"></canvas>

<script>
const canvas = document.getElementById('intro');
const ctx = canvas.getContext('2d'); /* 從畫布取得能進行 2D 繪圖的「畫筆工具」 */
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
/* 把 canvas 的大小設定成跟瀏覽器視窗一樣大，讓它變成全螢幕畫布 */

const centerX = canvas.width/2; /* 計算畫布的中心點 X 座標 */
const centerY = canvas.height/2; /* 計算畫布的中心點 Y 座標 */


const strawberryPattern = [
  [-2, -3, 'green'], [-1, -3, 'green'], [0, -3, 'green'], [1, -3, 'green'], [2, -3, 'green'], 
  [-3, -2, 'green'], [-2, -2, 'red'], [-1, -2, 'red'], [0, -2, 'red'], [1, -2, 'red'], 
  [2, -2, 'red'], [3, -2, 'green'],[-4, -1, 'red'], [-3, -1, 'red'], [-2, -1, 'red'], 
  [-1, -1, 'red'], [0, -1, 'red'], [1, -1, 'red'], [2, -1, 'red'], [3, -1, 'red'], 
  [4, -1, 'red'],[-4, 0, 'red'], [-3, 0, 'red'], [-2, 0, 'red'], [-1, 0, 'red'], 
  [0, 0, 'red'], [1, 0, 'red'], [2, 0, 'red'], [3, 0, 'red'], [4, 0, 'red'],
  [-3, 1, 'red'], [-2, 1, 'red'], [-1, 1, 'red'], [0, 1, 'red'], [1, 1, 'red'], 
  [2, 1, 'red'], [3, 1, 'red'],[-2, 2, 'red'], [-1, 2, 'red'], [0, 2, 'red'], 
  [1, 2, 'red'], [2, 2, 'red'],[-1, 3, 'red'], [0, 3, 'red'], [1, 3, 'red'],
  [0, 4, 'red'],[-1,0,'white'], [1,0,'white'], [0,1,'white']
]; /* 這邊只是寫出說 這麼多個陣列可以組合成草莓的圖案對 */

/* 這個陣列每個元素要 三個值 [x, y, color]，原因很直接：

x 座標：決定這個點在水平的位置（左右）。

y 座標：決定這個點在垂直的位置（上+9下）。

color 顏色：決定這個點要畫成什麼顏色（綠色葉子、紅色果實、白色高光）。 */

const speedPattern = [];
const letterMap = {
  S: ["1110","1000","1110","0010","1110"],
  P: ["110","101","110","100","100"],
  E: ["111","100","111","100","111"],
  D: ["110","101","101","101","110"] // 保留 D 形狀
};

function createLetterPattern(letter, offsetX){
  const pattern = [];
  const rows = letterMap[letter];
  rows.forEach((row, y)=>{
    row.split('').forEach((v, x)=>{
      if(v==='1') pattern.push([x+offsetX, y, 'white']);
    });
  });
  return pattern;
}

let offset = 0;
['S','P','E','E','D'].forEach(l=>{
  const letterPattern = createLetterPattern(l, offset);
  speedPattern.push(...letterPattern);
  offset += (letterMap[l][0].length + 1);
});

/* return 的意思是 把這個函式處理後的結果「回傳」出去 */
let blocks = strawberryPattern.map(p=>{
  return {
    x: Math.random()*canvas.width,
    y: Math.random()*canvas.height,
    targetX: centerX + p[0]*25, /* 方塊 20px + 外加 5px 間隔 = 25px */
    targetY: centerY + p[1]*25,
    size: 20,
    color: p[2],
    angle: Math.random()*Math.PI*2, /* 隨機初始角度 */
    angularVel: (Math.random()-0.5)*0.05,
    floatOffset: Math.random()*Math.PI*2
  };
});

let frame = 0;
let stage = 1; // 1: 草莓, 2: 草莓淡出 → SPEED拼合, 3: SPEED停留

function animate(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  if(stage===1){
    blocks.forEach(b=>{
      if(frame<60){
        b.x += (Math.random()-0.5)*5;
        b.y += (Math.random()-0.5)*5;
      } else {
        b.x += (b.targetX - b.x)*0.07;
        b.y += (b.targetY - b.y)*0.07;
        b.angle += b.angularVel;
        b.y += Math.sin(frame*0.05 + b.floatOffset)*0.3;
      }
      ctx.save();
      ctx.translate(b.x,b.y);
      ctx.rotate(b.angle);
      ctx.fillStyle = b.color;
      ctx.fillRect(-b.size/2,-b.size/2,b.size,b.size);
      ctx.restore();
    });

    frame++;
    if (frame > 150) {
      stage = 2;

      // --- 確保 SPEED 每格都有對應 block ---
      // 如果 blocks 不夠多，就補足
      while(blocks.length < speedPattern.length){
        blocks.push({
          x: Math.random()*canvas.width,
          y: Math.random()*canvas.height,
          size: 20,
          color: 'white',
          angle: Math.random()*Math.PI*2,
          angularVel: (Math.random()-0.5)*0.05,
          floatOffset: Math.random()*Math.PI*2
        });
      }

      // 計算 SPEED targetY 置中且底部對齊
      const ys = speedPattern.map(p => p[1]);
      const minY = Math.min(...ys);
      const maxY = Math.max(...ys);
      const totalHeight = maxY - minY + 1;

      blocks.forEach((b, i) => {
        const target = speedPattern[i % speedPattern.length];
        b.targetX = centerX + (target[0] - offset / 2) * 25;
        b.targetY = centerY + (target[1] - minY - (totalHeight-1)/2) * 25;
        b.color   = target[2];
      });

      frame = 0;
    }

  } else if(stage===2){
    blocks.forEach(b=>{
      b.x += (b.targetX - b.x)*0.07;
      b.y += (b.targetY - b.y)*0.07;
      b.angle += b.angularVel*0.2;

      ctx.save();
      ctx.translate(b.x,b.y);
      ctx.rotate(b.angle);
      ctx.fillStyle = b.color;
      ctx.fillRect(-b.size/2,-b.size/2,b.size,b.size);
      ctx.restore();
    });

    frame++;
    if(frame>120){
      stage=3;
      frame=0;
    }

  } else if(stage===3){
    blocks.forEach(b=>{
      ctx.save();
      ctx.translate(b.x,b.y);
      ctx.rotate(b.angle*0.1);
      ctx.fillStyle = b.color;
      ctx.fillRect(-b.size/2,-b.size/2,b.size,b.size);
      ctx.restore();
    });

    frame++;
    if(frame>240) showContent();
  }

  requestAnimationFrame(animate);
}

// --- 動畫結束後直接跳到 homepage.html ---
function showContent(){
  window.location.href = "/homepage";
}

animate();
</script>

</body>
</html>
